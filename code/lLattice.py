"""Creates one of different types of lattices.
    Inputs:
        l: the type of lattice (see output n for dictionary of names)
        u: the unit cell size
        t: thickness of the struts
    Output:
        d: the lattice object (sdf)
        n: dictionary of lattice names"""

__author__     = ['Mathias Bernhard']
__copyright__  = 'Copyright 2018 / Digital Building Technologies DBT'
__license__    = 'MIT License'
__email__      = ['<bernhard@arch.ethz.ch>']

import math
import Rhino.Geometry as rg


class Lattice(object):
    def __init__(self, ltype, unitcell, thickness):
        self.pointlist = self.create_points()
        self.types = self.create_types()
        self.type = min(max(0,ltype), len(self.types)-1)
        self.unitcell = unitcell
        self.thickness = thickness

    # ==========================================================================
    # descriptors
    # ==========================================================================

    @property
    def typenames(self):
        tn = ['bigx', 'grid', 'star', 'cross', 'octagon', 'octet', 'vintile', 'dual', 'interlock', 'isotrop', 'hextruss']
        d = {}
        for i, n in enumerate(tn):
            d[i] = n
        return d

    def create_points(self):
        """
        Creates a list of 20 points (xyz tuples) as possible strut anchors.
        The points are on the vertices (0-7) and edge centres (8-19) of a unit cell octant.
        """
        v1 = 0.0
        v2 = 0.5
        v3 = 0.25
        v4 = 0.2  # only used for hexgrid

        points = []

        points.append((v1, v1, v1))  #  0
        points.append((v2, v1, v1))  #  1
        points.append((v2, v2, v1))  #  2
        points.append((v1, v2, v1))  #  3

        points.append((v1, v1, v2))  #  4
        points.append((v2, v1, v2))  #  5
        points.append((v2, v2, v2))  #  6
        points.append((v1, v2, v2))  #  7

        points.append((v3, v1, v1))  #  8
        points.append((v2, v3, v1))  #  9
        points.append((v3, v2, v1))  # 10
        points.append((v1, v3, v1))  # 11

        points.append((v1, v1, v3))  # 12
        points.append((v2, v1, v3))  # 13
        points.append((v2, v2, v3))  # 14
        points.append((v1, v2, v3))  # 15

        points.append((v3, v1, v2))  # 16
        points.append((v2, v3, v2))  # 17
        points.append((v3, v2, v2))  # 18
        points.append((v1, v3, v2))  # 19

        points.append((v4, v1, v1))  # 20
        points.append((v1, v4, v1))  # 21
        points.append((v1, v1, v4))  # 22

        return points

    def create_types(self):
        """
        A lattice type is defined by a list of index tuples.
        The indices refer to `self.pointlist`, generated by `create_points` and specify start and end of each strut.
        """
        bigx = [(0, 6)]
        grid = [(6, 2), (6, 5), (6, 7)]
        star = grid + bigx
        cross = [(1, 6), (3, 6), (4, 6)]
        octagon = [(1, 3), (3, 4), (4, 1)]
        octet = cross + octagon
        vintile = [(8, 13), (13, 17), (17, 18), (18, 15), (15, 11), (11, 8)]
        dual = [(0, 1), (0, 3), (0, 4)]
        interlock = grid+dual
        isotrop = [(0, 1), (2, 1), (5, 1), (7, 1), (3, 7), (6, 7), (4, 7)]
        hextruss = [(6, 20), (6, 21), (6, 22)]

        types = [bigx, grid, star, cross, octagon, octet, vintile, dual, interlock, isotrop, hextruss]
        return types

    def get_distance(self, x, y, z):
        """
        single point distance function
        """

        up = [abs((p % self.unitcell) - self.unitcell/2) for p in (x,y,z)]
        dmin = 9999999.
        for l in self.types[self.type]:
            sp = [self.pointlist[l[0]][i] * self.unitcell for i in range(3)]
            ep = [self.pointlist[l[1]][i] * self.unitcell for i in range(3)]
            v = [ep[i]-sp[i] for i in range(3)]
            d = [up[i]-sp[i] for i in range(3)]
            # dot products
            c2 = sum([i*j for (i, j) in zip(v, v)])
            c1 = sum([i*j for (i, j) in zip(d, v)])

            b = c1/c2
            p = [sp[i] + b * v[i] for i in range(3)]
            dmin = min(dmin, sum([(up[i]-p[i])**2 for i in range(3)]))
        return math.sqrt(dmin) - self.thickness/2.0

if __name__ == "__main__":
    if l is None:
        l = 0
    l = min(max(l,0),10)
    if u is None:
        u = 1.0
    if t is None:
        t = .2
    d = Lattice(ltype=l, unitcell=u, thickness=t)
    n = [str(k)+" : "+d.typenames[k] for k in d.typenames]
